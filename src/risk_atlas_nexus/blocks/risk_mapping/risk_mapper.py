import datetime
import json
import re
from typing import List
from txtai import Embeddings
from sssom_schema import Mapping, EntityReference
from risk_atlas_nexus.ai_risk_ontology.datamodel.ai_risk_ontology import Risk
from risk_atlas_nexus.metadata_base import MappingMethod
from risk_atlas_nexus.blocks.risk_mapping import RiskMappingBase


class RiskMapper(RiskMappingBase):

    def _bucket_semantic_score(self, score: int):
        """A simplistic method to bucket the scores

        Args:
            score: int
                The semantic score to be processed

        Returns:
            str
                A representation of the relationship
        """
        relationship = 'noMatch'
        if score == 100:
            relationship = "skos:exactMatch"
        elif (score <= 100) and (score > 80):
            relationship = "skos:closeMatch"
        elif (score <= 80) and (score > 50):
            relationship = "skos:relatedMatch"
        elif (score <= 50) and (score > 20):
            relationship = "rdfs:seeAlso"

        return relationship
    
    def _format_with_curie(self, curie_prefix, id):
        """Format the string with curie prefix

        Args:
            curie_prefix: str
                The curie prefix
            id: str
                The linkml instance id

        Returns:
            EntityReference
                A formatted string
        """
        s = curie_prefix.strip() + ":" + id.strip()
        return EntityReference(s)
    

    def generate(self, new_risks: List[Risk], existing_risks: List[Risk], new_prefix: str, mapping_method: MappingMethod) -> List[Mapping]:
        """Generate a list of mappings between two lists of risks
        Args:
            new_risks List[Risk]:
                A new set of risks
            existing_risks: List[Risk],
                Secondary list, this should be the list of existing risks in RAN
            inference_engine: (Optional)Union[InferenceEngine | None]:
                An LLM inference engine to infer risks from the usecases.
            new_prefix: str
                A curie prefix for the new list
            mapping_method: MappingMethod
                The method to generate the mapping

        Returns:
            List[Mapping]
        """
        mappings = []
       
        if mapping_method == MappingMethod.SEMANTIC:
            # create an embedding with existing risk data
            data = []
            taxonomy_for_mapping= {}
            for risk in existing_risks:
                # this embedding is just using name and description, not any other attributes 
                data.append("ID: " + risk.id + ", Name: " + risk.name + ", Description: " + risk.description)
                taxonomy_for_mapping[risk.id] = risk.isDefinedByTaxonomy
            
            embeddings = Embeddings(path="sentence-transformers/nli-mpnet-base-v2")
            embeddings.index(data)

            # Run an embeddings search for each new risk
            for nr in new_risks:
                # Extract uid of first result
                # search result format: (uid, score)
                query = ("ID: " + nr.id + ", Name: " + nr.name + ", Description: " + nr.description)
                uid = embeddings.search(query, 5)[0][0]
                s = data[uid]
                result = re.search('ID:(.*), Name', s)
                result2 = re.search('Name:(.*), Description:', s)
                
                mapping = Mapping(subject_id= self._format_with_curie(new_prefix, nr.id), 
                                  subject_label=nr.name, 
                                  predicate_id=self._bucket_semantic_score(uid),
                                  object_id=self._format_with_curie(taxonomy_for_mapping[result.group(1).strip()], result.group(1)),
                                  object_label=result2.group(1),
                                  mapping_justification="semapv:SemanticSimilarityThresholdMatching",
                                  similarity_score=uid,
                                  mapping_date=datetime.date.today(),
                                  author_id="Risk_Atlas_Nexus_System",
                                  comment="Autogenerated via semantic similarity script")
                mappings.append(mapping)


        elif mapping_method == MappingMethod.RITS_INFERENCE:
            pass

       
        return mappings